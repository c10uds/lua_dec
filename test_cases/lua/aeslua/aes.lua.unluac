local L0_0
L0_0 = module
L0_0("aeslua.aes", package.seeall)
L0_0 = require
L0_0 = L0_0("bit")
aeslua.aes = {}
;({}).ROUNDS = "rounds"
;({}).KEY_TYPE = "type"
;({}).ENCRYPTION_KEY = 1
;({}).DECRYPTION_KEY = 2
;({}).SBox = {}
;({}).iSBox = {}
;({}).table0 = {}
;({}).table1 = {}
;({}).table2 = {}
;({}).table3 = {}
;({}).tableInv0 = {}
;({}).tableInv1 = {}
;({}).tableInv2 = {}
;({}).tableInv3 = {}
;({}).rCon = {
  16777216,
  33554432,
  67108864,
  134217728,
  268435456,
  536870912,
  1073741824,
  2147483648,
  452984832,
  905969664,
  1811939328,
  3623878656,
  2868903936,
  1291845632,
  2583691264,
  788529152
}
;({}).affinMap = function(A0_1)
  mask = 248
  result = 0
  for _FORV_4_ = 1, 8 do
    result = _UPVALUE0_.lshift(result, 1)
    parity = _UPVALUE1_.byteParity(_UPVALUE0_.band(A0_1, mask))
    result = result + parity
    lastbit = _UPVALUE0_.band(mask, 1)
    mask = _UPVALUE0_.band(_UPVALUE0_.rshift(mask, 1), 255)
    if lastbit ~= 0 then
      mask = _UPVALUE0_.bor(mask, 128)
    else
      mask = _UPVALUE0_.band(mask, 127)
    end
  end
  return _FOR_.bxor(result, 99)
end
;({}).calcSBox = function()
  local L0_2, L1_3, L2_4, L3_5
  for L3_5 = 0, 255 do
    if L3_5 ~= 0 then
      inverse = _UPVALUE0_.invert(L3_5)
    else
      inverse = L3_5
    end
    mapped = _UPVALUE1_.affinMap(inverse)
    _UPVALUE1_.SBox[L3_5] = mapped
    _UPVALUE1_.iSBox[mapped] = L3_5
  end
end
;({}).calcRoundTables = function()
  local L0_6, L1_7, L2_8, L3_9, L4_10
  for L3_9 = 0, 255 do
    L4_10 = _UPVALUE0_
    L4_10 = L4_10.SBox
    L4_10 = L4_10[L3_9]
    byte = L4_10
    L4_10 = _UPVALUE0_
    L4_10 = L4_10.table0
    L4_10[L3_9] = _UPVALUE1_.putByte(_UPVALUE2_.mul(3, byte), 0) + _UPVALUE1_.putByte(byte, 1) + _UPVALUE1_.putByte(byte, 2) + _UPVALUE1_.putByte(_UPVALUE2_.mul(2, byte), 3)
    L4_10 = _UPVALUE0_
    L4_10 = L4_10.table1
    L4_10[L3_9] = _UPVALUE1_.putByte(byte, 0) + _UPVALUE1_.putByte(byte, 1) + _UPVALUE1_.putByte(_UPVALUE2_.mul(2, byte), 2) + _UPVALUE1_.putByte(_UPVALUE2_.mul(3, byte), 3)
    L4_10 = _UPVALUE0_
    L4_10 = L4_10.table2
    L4_10[L3_9] = _UPVALUE1_.putByte(byte, 0) + _UPVALUE1_.putByte(_UPVALUE2_.mul(2, byte), 1) + _UPVALUE1_.putByte(_UPVALUE2_.mul(3, byte), 2) + _UPVALUE1_.putByte(byte, 3)
    L4_10 = _UPVALUE0_
    L4_10 = L4_10.table3
    L4_10[L3_9] = _UPVALUE1_.putByte(_UPVALUE2_.mul(2, byte), 0) + _UPVALUE1_.putByte(_UPVALUE2_.mul(3, byte), 1) + _UPVALUE1_.putByte(byte, 2) + _UPVALUE1_.putByte(byte, 3)
  end
end
;({}).calcInvRoundTables = function()
  local L0_11, L1_12, L2_13, L3_14, L4_15
  for L3_14 = 0, 255 do
    L4_15 = _UPVALUE0_
    L4_15 = L4_15.iSBox
    L4_15 = L4_15[L3_14]
    byte = L4_15
    L4_15 = _UPVALUE0_
    L4_15 = L4_15.tableInv0
    L4_15[L3_14] = _UPVALUE1_.putByte(_UPVALUE2_.mul(11, byte), 0) + _UPVALUE1_.putByte(_UPVALUE2_.mul(13, byte), 1) + _UPVALUE1_.putByte(_UPVALUE2_.mul(9, byte), 2) + _UPVALUE1_.putByte(_UPVALUE2_.mul(14, byte), 3)
    L4_15 = _UPVALUE0_
    L4_15 = L4_15.tableInv1
    L4_15[L3_14] = _UPVALUE1_.putByte(_UPVALUE2_.mul(13, byte), 0) + _UPVALUE1_.putByte(_UPVALUE2_.mul(9, byte), 1) + _UPVALUE1_.putByte(_UPVALUE2_.mul(14, byte), 2) + _UPVALUE1_.putByte(_UPVALUE2_.mul(11, byte), 3)
    L4_15 = _UPVALUE0_
    L4_15 = L4_15.tableInv2
    L4_15[L3_14] = _UPVALUE1_.putByte(_UPVALUE2_.mul(9, byte), 0) + _UPVALUE1_.putByte(_UPVALUE2_.mul(14, byte), 1) + _UPVALUE1_.putByte(_UPVALUE2_.mul(11, byte), 2) + _UPVALUE1_.putByte(_UPVALUE2_.mul(13, byte), 3)
    L4_15 = _UPVALUE0_
    L4_15 = L4_15.tableInv3
    L4_15[L3_14] = _UPVALUE1_.putByte(_UPVALUE2_.mul(14, byte), 0) + _UPVALUE1_.putByte(_UPVALUE2_.mul(11, byte), 1) + _UPVALUE1_.putByte(_UPVALUE2_.mul(13, byte), 2) + _UPVALUE1_.putByte(_UPVALUE2_.mul(9, byte), 3)
  end
end
;({}).rotWord = function(A0_16)
  local L1_17
  L1_17 = _UPVALUE0_
  L1_17 = L1_17.band
  L1_17 = L1_17(A0_16, 4278190080)
  return _UPVALUE0_.lshift(A0_16, 8) + _UPVALUE0_.rshift(L1_17, 24)
end
;({}).subWord = function(A0_18)
  return _UPVALUE0_.putByte(_UPVALUE1_.SBox[_UPVALUE0_.getByte(A0_18, 0)], 0) + _UPVALUE0_.putByte(_UPVALUE1_.SBox[_UPVALUE0_.getByte(A0_18, 1)], 1) + _UPVALUE0_.putByte(_UPVALUE1_.SBox[_UPVALUE0_.getByte(A0_18, 2)], 2) + _UPVALUE0_.putByte(_UPVALUE1_.SBox[_UPVALUE0_.getByte(A0_18, 3)], 3)
end
;({}).expandEncryptionKey = function(A0_19)
  local L1_20, L2_21, L3_22, L4_23, L5_24, L6_25, L7_26
  L1_20 = {}
  L2_21 = math
  L2_21 = L2_21.floor
  L2_21 = L2_21(L3_22)
  if L2_21 == 4 or L2_21 == 6 or L2_21 == 8 then
  elseif L3_22 ~= L4_23 then
    L3_22(L4_23, L5_24)
    return L3_22
  end
  L1_20[L3_22] = L4_23
  L1_20[L3_22] = L4_23
  for L6_25 = 0, L2_21 - 1 do
    L7_26 = _UPVALUE1_
    L7_26 = L7_26.putByte
    L7_26 = L7_26(A0_19[L6_25 * 4 + 1], 3)
    L7_26 = L7_26 + _UPVALUE1_.putByte(A0_19[L6_25 * 4 + 2], 2)
    L7_26 = L7_26 + _UPVALUE1_.putByte(A0_19[L6_25 * 4 + 3], 1)
    L7_26 = L7_26 + _UPVALUE1_.putByte(A0_19[L6_25 * 4 + 4], 0)
    L1_20[L6_25] = L7_26
  end
  for L6_25 = L2_21, L4_23 - 1 do
    L7_26 = L6_25 - 1
    L7_26 = L1_20[L7_26]
    if L6_25 % L2_21 == 0 then
      L7_26 = _UPVALUE2_.rotWord(L7_26)
      L7_26 = _UPVALUE2_.subWord(L7_26)
      L7_26 = _UPVALUE3_.bxor(L7_26, _UPVALUE2_.rCon[math.floor(L6_25 / L2_21)])
    elseif L2_21 > 6 and L6_25 % L2_21 == 4 then
      L7_26 = _UPVALUE2_.subWord(L7_26)
    end
    L1_20[L6_25] = _UPVALUE3_.bxor(L1_20[L6_25 - L2_21], L7_26)
  end
  return L1_20
end
;({}).invMixColumnOld = function(A0_27)
  local L1_28, L2_29, L3_30, L4_31
  L1_28 = _UPVALUE0_
  L1_28 = L1_28.getByte
  L2_29 = A0_27
  L3_30 = 3
  L1_28 = L1_28(L2_29, L3_30)
  L2_29 = _UPVALUE0_
  L2_29 = L2_29.getByte
  L3_30 = A0_27
  L4_31 = 2
  L2_29 = L2_29(L3_30, L4_31)
  L3_30 = _UPVALUE0_
  L3_30 = L3_30.getByte
  L4_31 = A0_27
  L3_30 = L3_30(L4_31, 1)
  L4_31 = _UPVALUE0_
  L4_31 = L4_31.getByte
  L4_31 = L4_31(A0_27, 0)
  return _UPVALUE0_.putByte(_UPVALUE1_.add(_UPVALUE1_.add(_UPVALUE1_.add(_UPVALUE1_.mul(11, L2_29), _UPVALUE1_.mul(13, L3_30)), _UPVALUE1_.mul(9, L4_31)), _UPVALUE1_.mul(14, L1_28)), 3) + _UPVALUE0_.putByte(_UPVALUE1_.add(_UPVALUE1_.add(_UPVALUE1_.add(_UPVALUE1_.mul(11, L3_30), _UPVALUE1_.mul(13, L4_31)), _UPVALUE1_.mul(9, L1_28)), _UPVALUE1_.mul(14, L2_29)), 2) + _UPVALUE0_.putByte(_UPVALUE1_.add(_UPVALUE1_.add(_UPVALUE1_.add(_UPVALUE1_.mul(11, L4_31), _UPVALUE1_.mul(13, L1_28)), _UPVALUE1_.mul(9, L2_29)), _UPVALUE1_.mul(14, L3_30)), 1) + _UPVALUE0_.putByte(_UPVALUE1_.add(_UPVALUE1_.add(_UPVALUE1_.add(_UPVALUE1_.mul(11, L1_28), _UPVALUE1_.mul(13, L2_29)), _UPVALUE1_.mul(9, L3_30)), _UPVALUE1_.mul(14, L4_31)), 0)
end
;({}).invMixColumn = function(A0_32)
  local L1_33, L2_34, L3_35, L4_36, L5_37, L6_38, L7_39
  L1_33 = _UPVALUE0_
  L1_33 = L1_33.getByte
  L2_34 = A0_32
  L3_35 = 3
  L1_33 = L1_33(L2_34, L3_35)
  L2_34 = _UPVALUE0_
  L2_34 = L2_34.getByte
  L3_35 = A0_32
  L4_36 = 2
  L2_34 = L2_34(L3_35, L4_36)
  L3_35 = _UPVALUE0_
  L3_35 = L3_35.getByte
  L4_36 = A0_32
  L5_37 = 1
  L3_35 = L3_35(L4_36, L5_37)
  L4_36 = _UPVALUE0_
  L4_36 = L4_36.getByte
  L5_37 = A0_32
  L6_38 = 0
  L4_36 = L4_36(L5_37, L6_38)
  L5_37 = _UPVALUE1_
  L5_37 = L5_37.bxor
  L6_38 = L4_36
  L7_39 = L3_35
  L5_37 = L5_37(L6_38, L7_39)
  L6_38 = _UPVALUE1_
  L6_38 = L6_38.bxor
  L7_39 = L2_34
  L6_38 = L6_38(L7_39, L1_33)
  L7_39 = _UPVALUE1_
  L7_39 = L7_39.bxor
  L7_39 = L7_39(L5_37, L6_38)
  L7_39 = _UPVALUE1_.bxor(L7_39, _UPVALUE2_.mul(8, L7_39))
  w = _UPVALUE1_.bxor(L7_39, _UPVALUE2_.mul(4, _UPVALUE1_.bxor(L3_35, L1_33)))
  L7_39 = _UPVALUE1_.bxor(L7_39, _UPVALUE2_.mul(4, _UPVALUE1_.bxor(L4_36, L2_34)))
  return _UPVALUE0_.putByte(_UPVALUE1_.bxor(_UPVALUE1_.bxor(L4_36, L7_39), _UPVALUE2_.mul(2, _UPVALUE1_.bxor(L1_33, L4_36))), 0) + _UPVALUE0_.putByte(_UPVALUE1_.bxor(_UPVALUE1_.bxor(L3_35, w), _UPVALUE2_.mul(2, L5_37)), 1) + _UPVALUE0_.putByte(_UPVALUE1_.bxor(_UPVALUE1_.bxor(L2_34, L7_39), _UPVALUE2_.mul(2, _UPVALUE1_.bxor(L1_33, L4_36))), 2) + _UPVALUE0_.putByte(_UPVALUE1_.bxor(_UPVALUE1_.bxor(L1_33, w), _UPVALUE2_.mul(2, L6_38)), 3)
end
;({}).expandDecryptionKey = function(A0_40)
  if _UPVALUE0_.expandEncryptionKey(A0_40) == nil then
    return nil
  end
  _UPVALUE0_.expandEncryptionKey(A0_40)[_UPVALUE0_.KEY_TYPE] = _UPVALUE0_.DECRYPTION_KEY
  for _FORV_5_ = 4, (_UPVALUE0_.expandEncryptionKey(A0_40)[_UPVALUE0_.ROUNDS] + 1) * 4 - 5 do
    _UPVALUE0_.expandEncryptionKey(A0_40)[_FORV_5_] = _UPVALUE1_.invMixColumnOld(_UPVALUE0_.expandEncryptionKey(A0_40)[_FORV_5_])
  end
  return (_UPVALUE0_.expandEncryptionKey(A0_40))
end
;({}).addRoundKey = function(A0_41, A1_42, A2_43)
  local L3_44, L4_45, L5_46, L6_47
  for L6_47 = 0, 3 do
    A0_41[L6_47] = _UPVALUE0_.bxor(A0_41[L6_47], A1_42[A2_43 * 4 + L6_47])
  end
end
;({}).doRound = function(A0_48, A1_49)
  A1_49[0] = _UPVALUE0_.bxor(_UPVALUE0_.bxor(_UPVALUE0_.bxor(_UPVALUE1_.table0[_UPVALUE2_.getByte(A0_48[0], 3)], _UPVALUE1_.table1[_UPVALUE2_.getByte(A0_48[1], 2)]), _UPVALUE1_.table2[_UPVALUE2_.getByte(A0_48[2], 1)]), _UPVALUE1_.table3[_UPVALUE2_.getByte(A0_48[3], 0)])
  A1_49[1] = _UPVALUE0_.bxor(_UPVALUE0_.bxor(_UPVALUE0_.bxor(_UPVALUE1_.table0[_UPVALUE2_.getByte(A0_48[1], 3)], _UPVALUE1_.table1[_UPVALUE2_.getByte(A0_48[2], 2)]), _UPVALUE1_.table2[_UPVALUE2_.getByte(A0_48[3], 1)]), _UPVALUE1_.table3[_UPVALUE2_.getByte(A0_48[0], 0)])
  A1_49[2] = _UPVALUE0_.bxor(_UPVALUE0_.bxor(_UPVALUE0_.bxor(_UPVALUE1_.table0[_UPVALUE2_.getByte(A0_48[2], 3)], _UPVALUE1_.table1[_UPVALUE2_.getByte(A0_48[3], 2)]), _UPVALUE1_.table2[_UPVALUE2_.getByte(A0_48[0], 1)]), _UPVALUE1_.table3[_UPVALUE2_.getByte(A0_48[1], 0)])
  A1_49[3] = _UPVALUE0_.bxor(_UPVALUE0_.bxor(_UPVALUE0_.bxor(_UPVALUE1_.table0[_UPVALUE2_.getByte(A0_48[3], 3)], _UPVALUE1_.table1[_UPVALUE2_.getByte(A0_48[0], 2)]), _UPVALUE1_.table2[_UPVALUE2_.getByte(A0_48[1], 1)]), _UPVALUE1_.table3[_UPVALUE2_.getByte(A0_48[2], 0)])
end
;({}).doLastRound = function(A0_50, A1_51)
  A1_51[0] = _UPVALUE0_.putByte(_UPVALUE1_.SBox[_UPVALUE0_.getByte(A0_50[0], 3)], 3) + _UPVALUE0_.putByte(_UPVALUE1_.SBox[_UPVALUE0_.getByte(A0_50[1], 2)], 2) + _UPVALUE0_.putByte(_UPVALUE1_.SBox[_UPVALUE0_.getByte(A0_50[2], 1)], 1) + _UPVALUE0_.putByte(_UPVALUE1_.SBox[_UPVALUE0_.getByte(A0_50[3], 0)], 0)
  A1_51[1] = _UPVALUE0_.putByte(_UPVALUE1_.SBox[_UPVALUE0_.getByte(A0_50[1], 3)], 3) + _UPVALUE0_.putByte(_UPVALUE1_.SBox[_UPVALUE0_.getByte(A0_50[2], 2)], 2) + _UPVALUE0_.putByte(_UPVALUE1_.SBox[_UPVALUE0_.getByte(A0_50[3], 1)], 1) + _UPVALUE0_.putByte(_UPVALUE1_.SBox[_UPVALUE0_.getByte(A0_50[0], 0)], 0)
  A1_51[2] = _UPVALUE0_.putByte(_UPVALUE1_.SBox[_UPVALUE0_.getByte(A0_50[2], 3)], 3) + _UPVALUE0_.putByte(_UPVALUE1_.SBox[_UPVALUE0_.getByte(A0_50[3], 2)], 2) + _UPVALUE0_.putByte(_UPVALUE1_.SBox[_UPVALUE0_.getByte(A0_50[0], 1)], 1) + _UPVALUE0_.putByte(_UPVALUE1_.SBox[_UPVALUE0_.getByte(A0_50[1], 0)], 0)
  A1_51[3] = _UPVALUE0_.putByte(_UPVALUE1_.SBox[_UPVALUE0_.getByte(A0_50[3], 3)], 3) + _UPVALUE0_.putByte(_UPVALUE1_.SBox[_UPVALUE0_.getByte(A0_50[0], 2)], 2) + _UPVALUE0_.putByte(_UPVALUE1_.SBox[_UPVALUE0_.getByte(A0_50[1], 1)], 1) + _UPVALUE0_.putByte(_UPVALUE1_.SBox[_UPVALUE0_.getByte(A0_50[2], 0)], 0)
end
;({}).doInvRound = function(A0_52, A1_53)
  A1_53[0] = _UPVALUE0_.bxor(_UPVALUE0_.bxor(_UPVALUE0_.bxor(_UPVALUE1_.tableInv0[_UPVALUE2_.getByte(A0_52[0], 3)], _UPVALUE1_.tableInv1[_UPVALUE2_.getByte(A0_52[3], 2)]), _UPVALUE1_.tableInv2[_UPVALUE2_.getByte(A0_52[2], 1)]), _UPVALUE1_.tableInv3[_UPVALUE2_.getByte(A0_52[1], 0)])
  A1_53[1] = _UPVALUE0_.bxor(_UPVALUE0_.bxor(_UPVALUE0_.bxor(_UPVALUE1_.tableInv0[_UPVALUE2_.getByte(A0_52[1], 3)], _UPVALUE1_.tableInv1[_UPVALUE2_.getByte(A0_52[0], 2)]), _UPVALUE1_.tableInv2[_UPVALUE2_.getByte(A0_52[3], 1)]), _UPVALUE1_.tableInv3[_UPVALUE2_.getByte(A0_52[2], 0)])
  A1_53[2] = _UPVALUE0_.bxor(_UPVALUE0_.bxor(_UPVALUE0_.bxor(_UPVALUE1_.tableInv0[_UPVALUE2_.getByte(A0_52[2], 3)], _UPVALUE1_.tableInv1[_UPVALUE2_.getByte(A0_52[1], 2)]), _UPVALUE1_.tableInv2[_UPVALUE2_.getByte(A0_52[0], 1)]), _UPVALUE1_.tableInv3[_UPVALUE2_.getByte(A0_52[3], 0)])
  A1_53[3] = _UPVALUE0_.bxor(_UPVALUE0_.bxor(_UPVALUE0_.bxor(_UPVALUE1_.tableInv0[_UPVALUE2_.getByte(A0_52[3], 3)], _UPVALUE1_.tableInv1[_UPVALUE2_.getByte(A0_52[2], 2)]), _UPVALUE1_.tableInv2[_UPVALUE2_.getByte(A0_52[1], 1)]), _UPVALUE1_.tableInv3[_UPVALUE2_.getByte(A0_52[0], 0)])
end
;({}).doInvLastRound = function(A0_54, A1_55)
  A1_55[0] = _UPVALUE0_.putByte(_UPVALUE1_.iSBox[_UPVALUE0_.getByte(A0_54[0], 3)], 3) + _UPVALUE0_.putByte(_UPVALUE1_.iSBox[_UPVALUE0_.getByte(A0_54[3], 2)], 2) + _UPVALUE0_.putByte(_UPVALUE1_.iSBox[_UPVALUE0_.getByte(A0_54[2], 1)], 1) + _UPVALUE0_.putByte(_UPVALUE1_.iSBox[_UPVALUE0_.getByte(A0_54[1], 0)], 0)
  A1_55[1] = _UPVALUE0_.putByte(_UPVALUE1_.iSBox[_UPVALUE0_.getByte(A0_54[1], 3)], 3) + _UPVALUE0_.putByte(_UPVALUE1_.iSBox[_UPVALUE0_.getByte(A0_54[0], 2)], 2) + _UPVALUE0_.putByte(_UPVALUE1_.iSBox[_UPVALUE0_.getByte(A0_54[3], 1)], 1) + _UPVALUE0_.putByte(_UPVALUE1_.iSBox[_UPVALUE0_.getByte(A0_54[2], 0)], 0)
  A1_55[2] = _UPVALUE0_.putByte(_UPVALUE1_.iSBox[_UPVALUE0_.getByte(A0_54[2], 3)], 3) + _UPVALUE0_.putByte(_UPVALUE1_.iSBox[_UPVALUE0_.getByte(A0_54[1], 2)], 2) + _UPVALUE0_.putByte(_UPVALUE1_.iSBox[_UPVALUE0_.getByte(A0_54[0], 1)], 1) + _UPVALUE0_.putByte(_UPVALUE1_.iSBox[_UPVALUE0_.getByte(A0_54[3], 0)], 0)
  A1_55[3] = _UPVALUE0_.putByte(_UPVALUE1_.iSBox[_UPVALUE0_.getByte(A0_54[3], 3)], 3) + _UPVALUE0_.putByte(_UPVALUE1_.iSBox[_UPVALUE0_.getByte(A0_54[2], 2)], 2) + _UPVALUE0_.putByte(_UPVALUE1_.iSBox[_UPVALUE0_.getByte(A0_54[1], 1)], 1) + _UPVALUE0_.putByte(_UPVALUE1_.iSBox[_UPVALUE0_.getByte(A0_54[0], 0)], 0)
end
;({}).encrypt = function(A0_56, A1_57, A2_58, A3_59, A4_60)
  local L5_61, L6_62, L7_63
  A2_58 = A2_58 or 1
  if not A3_59 then
    L5_61 = {}
    A3_59 = L5_61
  end
  A4_60 = A4_60 or 1
  L5_61 = {}
  L6_62 = {}
  L7_63 = _UPVALUE0_
  L7_63 = L7_63.KEY_TYPE
  L7_63 = A0_56[L7_63]
  if L7_63 ~= _UPVALUE0_.ENCRYPTION_KEY then
    L7_63 = print
    L7_63("No encryption key: ", A0_56[_UPVALUE0_.KEY_TYPE])
    return
  end
  L7_63 = _UPVALUE1_
  L7_63 = L7_63.bytesToInts
  L7_63 = L7_63(A1_57, A2_58, 4)
  L5_61 = L7_63
  L7_63 = _UPVALUE2_
  L7_63 = L7_63.addRoundKey
  L7_63(L5_61, A0_56, 0)
  L7_63 = 1
  while L7_63 < A0_56[_UPVALUE0_.ROUNDS] - 1 do
    _UPVALUE2_.doRound(L5_61, L6_62)
    _UPVALUE2_.addRoundKey(L6_62, A0_56, L7_63)
    L7_63 = L7_63 + 1
    _UPVALUE2_.doRound(L6_62, L5_61)
    _UPVALUE2_.addRoundKey(L5_61, A0_56, L7_63)
    L7_63 = L7_63 + 1
  end
  _UPVALUE2_.doRound(L5_61, L6_62)
  _UPVALUE2_.addRoundKey(L6_62, A0_56, L7_63)
  L7_63 = L7_63 + 1
  _UPVALUE2_.doLastRound(L6_62, L5_61)
  _UPVALUE2_.addRoundKey(L5_61, A0_56, L7_63)
  return _UPVALUE1_.intsToBytes(L5_61, A3_59, A4_60)
end
;({}).decrypt = function(A0_64, A1_65, A2_66, A3_67, A4_68)
  local L5_69, L6_70, L7_71
  A2_66 = A2_66 or 1
  if not A3_67 then
    L5_69 = {}
    A3_67 = L5_69
  end
  A4_68 = A4_68 or 1
  L5_69 = {}
  L6_70 = {}
  L7_71 = _UPVALUE0_
  L7_71 = L7_71.KEY_TYPE
  L7_71 = A0_64[L7_71]
  if L7_71 ~= _UPVALUE0_.DECRYPTION_KEY then
    L7_71 = print
    L7_71("No decryption key: ", A0_64[_UPVALUE0_.KEY_TYPE])
    return
  end
  L7_71 = _UPVALUE1_
  L7_71 = L7_71.bytesToInts
  L7_71 = L7_71(A1_65, A2_66, 4)
  L5_69 = L7_71
  L7_71 = _UPVALUE2_
  L7_71 = L7_71.addRoundKey
  L7_71(L5_69, A0_64, A0_64[_UPVALUE0_.ROUNDS])
  L7_71 = _UPVALUE0_
  L7_71 = L7_71.ROUNDS
  L7_71 = A0_64[L7_71]
  L7_71 = L7_71 - 1
  while L7_71 > 2 do
    _UPVALUE2_.doInvRound(L5_69, L6_70)
    _UPVALUE2_.addRoundKey(L6_70, A0_64, L7_71)
    L7_71 = L7_71 - 1
    _UPVALUE2_.doInvRound(L6_70, L5_69)
    _UPVALUE2_.addRoundKey(L5_69, A0_64, L7_71)
    L7_71 = L7_71 - 1
  end
  _UPVALUE2_.doInvRound(L5_69, L6_70)
  _UPVALUE2_.addRoundKey(L6_70, A0_64, L7_71)
  L7_71 = L7_71 - 1
  _UPVALUE2_.doInvLastRound(L6_70, L5_69)
  _UPVALUE2_.addRoundKey(L5_69, A0_64, L7_71)
  return _UPVALUE1_.intsToBytes(L5_69, A3_67, A4_68)
end
;({}).calcSBox()
;({}).calcRoundTables()
;({}).calcInvRoundTables()
return {}
